Hello - from /home/vlassis/.vscode/extensions/jaredly.reason-vscode-1.7.5/bin.native.linux
Previous log location: /tmp/lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json"}, {"globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/vlassis/Desktop/Compiler/workspace/Codegen.ml","languageId":"ocaml","version":1,"text":"open Llvm\r\nopen Llvm_analysis\r\nopen Ast\r\nopen Error\r\nopen Types\r\nopen Symbol\r\n\r\nexception Error of string\r\n\r\nlet context = global_context ()\r\nlet the_module = create_module context \"alan\"\r\nlet builder = builder context\r\n\r\nlet int_type = i16_type context (* lltype *)\r\nlet byte_type = i8_type context\r\nlet bool_type = i1_type context\r\nlet proc_type = void_type context\r\n\r\n(* Helping functions *)\r\n\r\nlet rec give_lltype alan_type =\r\n    begin match alan_type with\r\n        | TYPE_int                          -> int_type\r\n        | TYPE_byte                         -> byte_type\r\n        | TYPE_array (elem_type, _)         -> pointer_type (give_lltype elem_type) (* element type can only be a basic data type in alan - int or byte *)\r\n        | _ -> fatal \"alan to lltype didn't work\"; raise Terminate\r\n    end\r\n\r\nlet rec give_fret_lltype alan_type =\r\n    begin match alan_type with\r\n        | TYPE_int  -> int_type\r\n        | TYPE_byte -> byte_type\r\n        | TYPE_proc -> proc_type\r\n        | _ -> fatal \"alan to return type didn't work\"; raise Terminate\r\n    end\r\n\r\nlet rec give_par_lltype_lst par_lst =\r\n    begin match par_lst with\r\n        | pr :: tl ->\r\n            begin match pr.par_type with\r\n                | TYPE_array _  ->  (give_lltype pr.par_type) :: (give_par_lltype_lst tl)\r\n                | _             ->  begin match pr.par_pass_way with\r\n                                        | PASS_BY_VALUE     -> (give_lltype pr.par_type) :: (give_par_lltype_lst tl)\r\n                                        | PASS_BY_REFERENCE -> (pointer_type (give_lltype pr.par_type)):: (give_par_lltype_lst tl)\r\n                                    end\r\n            end\r\n        | [] -> []\r\n    end\r\n\r\nlet rec give_locvar_lltype_lst loc_lst =\r\n    begin match loc_lst with\r\n        | (Local_var vr) :: tl  -> (give_lltype vr.var_type) :: (give_locvar_lltype_lst tl)\r\n        | (Local_func _) :: tl  -> give_locvar_lltype_lst tl\r\n        | []                    -> []\r\n    end\r\n\r\nlet give_frame_lltype parent_frame_type func_pars func_local =\r\n\r\n    let par_lltype_lst = give_par_lltype_lst func_pars in (* List of parameter lltypes *)\r\n    let locvar_lltype_lst = give_locvar_lltype_lst func_local in (* List of local-variable lltyppes (without local funcs) *)\r\n\r\n    let access_link_type = pointer_type parent_frame_type in \r\n    let arr_of_lltypes = Array.of_list ( access_link_type :: (par_lltype_lst @ locvar_lltype_lst) ) in (* Array of lltypes for frame lltype *)\r\n\r\n    let ll_frame_type = struct_type context arr_of_lltypes in (* Frame lltype (llvm-struct type) *)\r\n\r\n    ll_frame_type\r\n\r\nlet give_func_lltype parent_frame_type func_pars func_ret_type  =\r\n\r\n    let par_lltype_lst = give_par_lltype_lst func_pars in (* List of parameter lltypes *)\r\n    let access_link_type = pointer_type parent_frame_type in \r\n\r\n    let par_llarr = Array.of_list (access_link_type :: par_lltype_lst) in\r\n    let fret_lltype = give_fret_lltype func_ret_type in (* LLtype of function's return value *)\r\n\r\n    let func_lltype = function_type fret_lltype par_llarr in (*Function lltype *)\r\n\r\n    func_lltype\r\n\r\nlet get_ptr_to_Nth_element struct_ptr n = build_struct_gep struct_ptr n \"ptr to nth element\" builder\r\n\r\nlet dereference ptr = build_load ptr \"de-reference\" builder\r\n\r\nlet get_ptr_to_new_array arr_lltype arr_size = \r\n    let arr_typ = array_type arr_lltype arr_size in\r\n    let arr = build_alloca arr_typ \"array allocation\" builder in\r\n    let ptr = get_ptr_to_Nth_element arr 0 in\r\n    ptr\r\n\r\nlet store_at_struct llvalue_tostore struct_ptr idx =\r\n    let element_ptr_llvalue = get_ptr_to_Nth_element struct_ptr idx in\r\n    ignore (build_store llvalue_tostore element_ptr_llvalue builder)\r\n\r\n(* Note: access_link == frame_ptr *)\r\nlet rec get_deep_access_link frame_ptr diff =\r\n    if( diff = 0 ) \r\n    then begin\r\n        frame_ptr\r\n    end\r\n    else begin\r\n        let first_element = dereference (get_ptr_to_Nth_element frame_ptr 0) in\r\n        get_deep_access_link first_element (diff-1)\r\n    end\r\n    \r\n(* End of helping functions *)\r\n\r\nand codegen_func func_ast =\r\n\r\n    let parent_frame_type = match func_ast.parent with \r\n        | Some some_parent ->\r\n            begin match some_parent.frame_type with\r\n                | Some some_frame_type -> some_frame_type\r\n                | None -> fatal \"parent function does not have a frame type\"; raise Terminate\r\n            end\r\n        | None -> fatal \"function does not have a parent\"; raise Terminate\r\n    in\r\n\r\n    let func_lltype = give_func_lltype parent_frame_type func_ast.func_pars func_ast.func_ret_type in\r\n    let frame_type = give_frame_lltype parent_frame_type func_ast.func_pars func_ast.func_local in\r\n    func_ast.frame_type <- Some frame_type;\r\n\r\n    (* Declare first *)\r\n    let func_llvalue = declare_function func_ast.full_name func_lltype the_module in\r\n\r\n    (* Generate code for local functions *)\r\n    let gen_loc_func loc = match loc with\r\n        | Local_func loc_func -> codegen_func loc_func\r\n        | Local_var _         -> ()  \r\n    in\r\n    List.iter gen_loc_func func_ast.func_local;\r\n\r\n    (* Create function basic-block *)\r\n    let f_bb = append_block context \"entry block\" func_llvalue in\r\n    position_at_end f_bb builder;\r\n\r\n    (* Create frame *)\r\n    let frame_ptr = build_alloca frame_type \"frame\" builder in\r\n\r\n    (* Store each parameter into the frame *)\r\n    let store_par par_llvalue offset = ignore (store_at_struct par_llvalue frame_ptr offset) in\r\n    let par_llvalue_lst = Array.to_list (params func_llvalue) in\r\n\r\n    let give_offset pr = pr.par_offset in\r\n    let par_offsets = List.map give_offset func_ast.func_pars in\r\n\r\n    Printf.printf \"%d\" (List.length par_llvalue_lst) ; Printf.printf \"%d\" (List.length par_offsets) ;\r\n    (* Store starting from position 0 -- access link is included*)\r\n    List.iter2 store_par par_llvalue_lst (0 :: par_offsets);\r\n    \r\n    (* Store local var - simply allocate memory for the new arrays and store its pointer to the right position in frame *)\r\n    let rec store_vars loc_lst =\r\n        begin match loc_lst with\r\n            | (Local_var vr) :: tl  ->  begin match vr.var_type with\r\n                                            | TYPE_array (elem_type, arr_size) ->   let ptr_to_arr = get_ptr_to_new_array (give_lltype elem_type) arr_size in\r\n                                                                                    store_at_struct ptr_to_arr frame_ptr vr.var_offset;\r\n                                                                                    store_vars tl\r\n\r\n                                            | _                                ->   store_vars tl\r\n                                        end\r\n            | (Local_func _) :: tl  -> store_vars tl\r\n            | []                    -> []\r\n        end\r\n    in\r\n    ignore (store_vars func_ast.func_local);\r\n\r\n    (* Generate code for statements *)\r\n    ignore ( List.fold_left (codegen_stmt_until frame_ptr) false func_ast.func_stmt );\r\n\r\n    (* LLVM requires a terminator block *)\r\n    let _ = begin match block_terminator (insertion_block builder) with\r\n        | None      ->  begin match func_ast.func_ret_type with\r\n                            | TYPE_int      ->  ignore (build_ret (const_int int_type 0) builder)\r\n                            | TYPE_byte     ->  ignore (build_ret (const_int byte_type 0) builder)\r\n                            | TYPE_proc     ->  ignore (build_ret_void builder)\r\n                            | _             ->  fatal \"Codegen: invalid function return type\"; raise Terminate\r\n                        end\r\n\r\n        | Some _    ->  ()\r\n    end in \r\n    print_endline \"ending\";\r\n    ()\r\n\r\n\r\nand codegen_call frame_ptr call_ast =\r\n    (* https://en.wikipedia.org/wiki/Nested_function *)\r\n    let callee_full_name = match call_ast.callee_full_name with | Some name -> name | None -> fatal \"codegen_call: callee full name error\"; raise Terminate in\r\n    let callee_func_llvalue = match (lookup_function callee_full_name the_module) with | Some fn -> fn | None -> fatal \"codegen_call: Function not found\"; raise Terminate in\r\n\r\n    (* Must check if the callee is an existing function that doesn't need an access link *)\r\n    (* Idea: compare number of arguments in expr list with arguments declared through llvm *)\r\n    let access_link_is_required = \r\n        let llvm_args_num = Array.length (params callee_func_llvalue) in\r\n        let expr_args_num = List.length call_ast.call_expr in\r\n        llvm_args_num <> expr_args_num\r\n    in\r\n\r\n    let give_expr_llvalue declared exr = \r\n        begin match declared with\r\n            | PASS_BY_VALUE      -> codegen_expr frame_ptr exr\r\n            | PASS_BY_REFERENCE  -> \r\n                begin match exr.expr_raw with\r\n                    | E_lvalue lval ->  begin match lval.l_value_raw with\r\n                                            | L_id _     ->  codegen_lval frame_ptr lval\r\n\r\n                                            | L_str str  ->  let global_str = build_global_string str \"string to build\" builder in\r\n                                                             build_struct_gep global_str 0 \"string as a char ptr\" builder\r\n                                        end\r\n                    | _             ->  fatal \"passing by reference a non-lvalue\"; raise Terminate\r\n                end\r\n        end\r\n    in\r\n\r\n    let expr_arr = \r\n        let declared_lst = match call_ast.declared_pars with | Some lst -> lst | None -> fatal \"codegen_call: declared_pars empty\"; raise Terminate in\r\n        let expr_llvalue_lst = List.map2 give_expr_llvalue declared_lst call_ast.call_expr in\r\n        \r\n        if ( access_link_is_required ) then begin\r\n            print_endline \"yok\";\r\n            let diff = call_ast.caller_nesting_scope - call_ast.callee_scope + 1  in\r\n            let correct_frame = get_deep_access_link frame_ptr diff in\r\n\r\n            Array.of_list ( correct_frame :: expr_llvalue_lst )\r\n        end \r\n        else begin\r\n            print_endline \"nok\";\r\n            Array.of_list expr_llvalue_lst\r\n        end\r\n    in\r\n    build_call callee_func_llvalue expr_arr \"call\" builder\r\n\r\nand codegen_stmt_until frame_ptr previous_stmt_is_terminator st  = (* returns true if terminal *)\r\n    previous_stmt_is_terminator || codegen_stmt frame_ptr st\r\n\r\nand codegen_stmt frame_ptr stmt_ast = (* returns true if terminal *)\r\n    begin match stmt_ast with\r\n        | Null_stmt                 ->\r\n            false\r\n\r\n        | S_assign (lval,exr)        ->\r\n            let exr_llvalue = codegen_expr frame_ptr exr in\r\n            let element_ptr = codegen_lval frame_ptr lval in\r\n            ignore (build_store exr_llvalue element_ptr builder);\r\n            false\r\n\r\n        | S_comp st_lst             ->\r\n            List.fold_left (codegen_stmt_until frame_ptr) false st_lst\r\n            \r\n            (* List.iter (codegen_stmt frame_ptr) st_lst; *)\r\n\r\n        | S_call fcall              -> (* Call to a void function *)\r\n            ignore (codegen_call frame_ptr fcall);\r\n            false\r\n\r\n        | S_if (cnd, st, st_option) ->\r\n        (* http://llvm.org/docs/tutorial/OCamlLangImpl5.html *)\r\n            let cond_val = codegen_cond frame_ptr cnd in\r\n\r\n            (* Grab the first block so that we might later add the conditional branch\r\n            * to it at the end of the function. *)\r\n            let start_bb = insertion_block builder in\r\n            let the_function = block_parent start_bb in\r\n\r\n            let then_bb = append_block context \"then\" the_function in\r\n            let merge_bb = append_block context \"ifcont\" the_function in\r\n\r\n            position_at_end then_bb builder;\r\n            let then_stmt_is_terminal = codegen_stmt frame_ptr st in\r\n            let new_then_bb = insertion_block builder in (* Codegen of 'then' can change the current block *)\r\n\r\n            if(not then_stmt_is_terminal)\r\n            then begin\r\n                (* Set an unconditional branch at the end of the then-block to the merge-block *)\r\n                position_at_end new_then_bb builder; \r\n                ignore (build_br merge_bb builder)\r\n            end ;\r\n\r\n            let _ = match st_option with\r\n                | Some st_some ->\r\n                    let else_bb = append_block context \"else\" the_function in\r\n\r\n                    position_at_end else_bb builder;\r\n                    let else_stmt_is_terminal = codegen_stmt frame_ptr st_some in\r\n                    let new_else_bb = insertion_block builder in\r\n\r\n                    if( not else_stmt_is_terminal)\r\n                    then begin\r\n                        (* Set an unconditional branch at the end of the else-block to the merge-block*)\r\n                        position_at_end new_else_bb builder; \r\n                        ignore (build_br merge_bb builder)\r\n                    end;\r\n\r\n                    (* Return to the end of the start-block to add the conditional branch *)\r\n                    position_at_end start_bb builder;\r\n                    ignore ( build_cond_br cond_val then_bb else_bb builder )\r\n                    \r\n                    (* position_at_end merge_bb builder; *)\r\n                    (* then_stmt_is_terminal && else_stmt_is_terminal *)\r\n\r\n                | None ->\r\n                    (* Return to the end of the start-block to add the conditional branch *)\r\n                    position_at_end start_bb builder;\r\n                    ignore ( build_cond_br cond_val then_bb merge_bb builder )\r\n\r\n                    (* position_at_end merge_bb builder; *)\r\n                    (* false *)\r\n\r\n            in\r\n            (* Finally, set the builder to the end of the merge-block *)\r\n            position_at_end merge_bb builder;\r\n            false\r\n\r\n        | S_while (cnd, st)          ->\r\n            (* Grab the first block so that we later add the unconditional branch\r\n            * to it at the end of the function. *)\r\n            let start_bb = insertion_block builder in\r\n            let the_function = block_parent start_bb in\r\n\r\n            let while_bb = append_block context \"while\" the_function in\r\n            let do_bb = append_block context \"do\" the_function in\r\n            let merge_bb = append_block context \"continue\" the_function in\r\n\r\n            (* Set an unconditional branch at the end of the 'start' block to the start of the while-block *)\r\n            position_at_end start_bb builder; \r\n            ignore (build_br while_bb builder);\r\n\r\n            position_at_end while_bb builder;  \r\n            let cond_val = codegen_cond frame_ptr cnd in\r\n            let new_while_bb = insertion_block builder in (* Codegen of 'while' can change the current block *)\r\n            (* Add the conditional branch to either the do-block or the merge-block*)\r\n            position_at_end new_while_bb builder;\r\n            ignore (build_cond_br cond_val do_bb merge_bb builder);      \r\n\r\n            position_at_end do_bb builder;\r\n            let while_st_is_terminator = codegen_stmt frame_ptr st in\r\n            let new_do_bb = insertion_block builder in (* Codegen of 'do' can change the current block *)\r\n            \r\n            if (not while_st_is_terminator) then \r\n            begin\r\n                (* Set an unconditional branch to the start of the while-block *)\r\n                position_at_end new_do_bb builder; \r\n                ignore (build_br while_bb builder)\r\n            end;\r\n\r\n            (* Finally, set the builder to the end of the merge-block. *)\r\n            position_at_end merge_bb builder;\r\n\r\n            false\r\n\r\n        | S_return None             ->\r\n            ignore (build_ret_void builder);\r\n            true\r\n\r\n        | S_return (Some exr)        ->\r\n            let to_return_llvalue = codegen_expr frame_ptr exr in\r\n            ignore (build_ret to_return_llvalue builder);\r\n            true\r\n    end\r\n\r\nand codegen_expr frame_ptr expr_ast = (* never returns a (llvalue) ptr to anything *)\r\n    begin match expr_ast.expr_raw with\r\n        | E_int n                   -> const_int int_type n\r\n        | E_char c                  -> const_int byte_type (Char.code c)\r\n        | E_lvalue lval             ->  begin match lval.l_value_raw with\r\n                                            | L_id _  -> dereference (codegen_lval frame_ptr lval)\r\n                                            | L_str _ -> fatal \"codegen_expr: Cannot generate an expression from a string\"; raise Terminate\r\n                                        end\r\n\r\n        | E_call cl                 -> codegen_call frame_ptr cl\r\n        | E_sign (SPlus,exr)        -> codegen_expr frame_ptr exr\r\n        | E_sign (SMinus,exr)       -> build_neg (codegen_expr frame_ptr exr) \"neg\" builder\r\n        | E_op (er1, er_op, er2)    ->\r\n            let ller1 = codegen_expr frame_ptr er1 in\r\n            let ller2 = codegen_expr frame_ptr er2 in\r\n            begin match er_op with\r\n                | Plus  -> build_add ller1 ller2 \"add\" builder\r\n                | Minus -> build_sub ller1 ller2 \"sub\" builder\r\n                | Mult  -> build_mul ller1 ller2 \"mul\" builder\r\n                | Div   -> \r\n                    begin match (er1.expr_type, er2.expr_type) with \r\n                        | (Some TYPE_int, Some TYPE_int)   -> build_sdiv ller1 ller2 \"sdiv\" builder\r\n                        | (Some TYPE_byte, Some TYPE_byte) -> build_udiv ller1 ller2 \"udiv\" builder\r\n                        | _ -> fatal \"exprgen div, type mismatch\"; raise Terminate\r\n                    end\r\n                | Mod   -> \r\n                    begin match (er1.expr_type, er2.expr_type) with \r\n                        | (Some TYPE_int, Some TYPE_int)   -> build_srem ller1 ller2 \"smod\" builder\r\n                        | (Some TYPE_byte, Some TYPE_byte) -> build_urem ller1 ller2 \"umod\" builder\r\n                        | _ -> fatal \"exprgen mod, type mismatch\"; raise Terminate\r\n                    end\r\n            end \r\n    end\r\n\r\nand codegen_lval frame_ptr l_value_ast = (* returns a (llvalue) pointer to the element *)\r\n    let correct_frame = get_deep_access_link frame_ptr l_value_ast.l_value_nesting_diff in\r\n\r\n    begin match l_value_ast.l_value_raw with\r\n        | L_id (_, None)      ->    if (l_value_ast.is_reference)\r\n                                    then(\r\n                                        dereference (get_ptr_to_Nth_element correct_frame l_value_ast.offset)\r\n                                    ) else (\r\n                                        get_ptr_to_Nth_element correct_frame l_value_ast.offset\r\n                                    )\r\n        | L_id (_, Some exr)  -> (* Only arrays here -- is always reference *) if(not l_value_ast.is_reference) then (fatal \"codegen_lval: must be a reference\"; raise Terminate);\r\n                                    let lval_exr = codegen_expr frame_ptr exr in\r\n                                    let arr_ptr = dereference (get_ptr_to_Nth_element correct_frame l_value_ast.offset) in\r\n                                    build_in_bounds_gep arr_ptr [|lval_exr|] \"ptr to EXPRth element in array\" builder\r\n\r\n        | L_str str           -> fatal \"codegen_lval: Cannot give ptr to string; do it only during calls to existing funcs\"; raise Terminate\r\n            \r\n    end\r\n\r\nand codegen_cond frame_ptr cond_ast =\r\n    let give_ll_cmp_op alan_op is_signed = match is_signed, alan_op with\r\n        | _, Eq -> Icmp.Eq\r\n        | _, Neq -> Icmp.Ne\r\n\r\n        | true, Less -> Icmp.Slt\r\n        | true, Great -> Icmp.Sgt\r\n        | true, LessEq -> Icmp.Sle\r\n        | true, GreatEq -> Icmp.Sge\r\n\r\n        | false, Less -> Icmp.Ult\r\n        | false, Great -> Icmp.Ugt\r\n        | false, LessEq -> Icmp.Ule\r\n        | false, GreatEq -> Icmp.Uge\r\n    in\r\n\r\n    let is_expr_signed exr = match exr.expr_type with\r\n        | Some TYPE_int     -> true\r\n        | Some TYPE_byte    -> false\r\n        | _                 -> fatal \"is_expr_signed: type is not int or byte\"; raise Terminate\r\n    in\r\n\r\n    begin match cond_ast with\r\n        | C_true                        -> const_int bool_type 1\r\n        | C_false                       -> const_int bool_type 0\r\n        | C_not cnd                     -> build_not (codegen_cond frame_ptr cnd) \"not\" builder\r\n        | C_compare (er1, cmp_op, er2)  -> build_icmp (give_ll_cmp_op cmp_op (is_expr_signed er1)) (codegen_expr frame_ptr er1) (codegen_expr frame_ptr er2) \"icmp\" builder\r\n        | C_logic (cnd1, lg_op, cnd2)   ->\r\n            let start_bb = insertion_block builder in\r\n            let the_function = block_parent start_bb in\r\n\r\n            let middle_bb = append_block context \"middle_bb\" the_function in\r\n            let merge_bb = append_block context \"merge_bb\" the_function in\r\n\r\n            (* position_at_end start_bb builder; *)\r\n            let cnd1_llvalue = codegen_cond frame_ptr cnd1 in\r\n\r\n            let midway logical_operator = match logical_operator with\r\n                | And ->\r\n                    (* If cnd1 is true then (must compute cnd2) middle_bb else merge_bb *)\r\n                    ignore (build_cond_br cnd1_llvalue middle_bb merge_bb builder);\r\n                    let new_start_bb = insertion_block builder in\r\n\r\n                    position_at_end middle_bb builder;\r\n                    let middle_llvalue = build_and cnd1_llvalue (codegen_cond frame_ptr cnd2) \"and\" builder in\r\n                    ignore (build_br merge_bb builder);\r\n                    let new_middle_bb = insertion_block builder in\r\n\r\n                    (new_start_bb, middle_llvalue, new_middle_bb)\r\n\r\n                | Or  ->\r\n                    (* If cnd1 is true then (no need to compute cnd2) merge_bb else middle_bb *)\r\n                    ignore (build_cond_br cnd1_llvalue merge_bb middle_bb builder);\r\n                    let new_start_bb = insertion_block builder in\r\n\r\n                    position_at_end middle_bb builder;\r\n                    let middle_llvalue = build_or cnd1_llvalue (codegen_cond frame_ptr cnd2) \"or\" builder in\r\n                    ignore (build_br merge_bb builder);\r\n                    let new_middle_bb = insertion_block builder in\r\n                    \r\n                    (new_start_bb, middle_llvalue, new_middle_bb)\r\n            in\r\n\r\n            let (new_start_bb, middle_llvalue, new_middle_bb) = midway lg_op in\r\n\r\n            position_at_end merge_bb builder;\r\n            let phi = build_phi [(cnd1_llvalue, new_start_bb) ; (middle_llvalue, new_middle_bb)] \"phi\" builder in\r\n            position_at_end merge_bb builder;\r\n            phi\r\n    end\r\n\r\nlet codegen_existing_functions () = \r\n    \r\n    let codegen_block func_llvalue =\r\n        (* Create function basic-block *)\r\n        let f_bb = append_block context \"entry block\" func_llvalue in\r\n        position_at_end f_bb builder\r\n    in\r\n\r\n    let codegen_declare full_name ret_type pars = \r\n        let pars_arr = Array.of_list pars in\r\n        let func_lltype = function_type ret_type pars_arr in\r\n        declare_function full_name func_lltype the_module\r\n    in\r\n\r\n    let _    = codegen_declare \"writeInteger\"    proc_type [int_type] in\r\n    let _    = codegen_declare \"writeChar\"       proc_type [byte_type] in\r\n    let _    = codegen_declare \"writeString\"     proc_type [pointer_type byte_type] in\r\n    let _    = codegen_declare \"readInteger\"     int_type  [] in\r\n    let _    = codegen_declare \"readChar\"        byte_type [] in\r\n    let _    = codegen_declare \"readString\"      proc_type [int_type; pointer_type byte_type] in\r\n    let _    = codegen_declare \"strlen\"          int_type  [pointer_type byte_type] in\r\n    let _    = codegen_declare \"strcmp\"          int_type  [pointer_type byte_type; pointer_type byte_type] in\r\n    let _    = codegen_declare \"strcpy\"          proc_type [pointer_type byte_type; pointer_type byte_type] in\r\n    let _    = codegen_declare \"strcat\"          proc_type [pointer_type byte_type; pointer_type byte_type] in\r\n\r\n    (* extend (b : byte) : int *)\r\n    let extend          = codegen_declare \"extend\" int_type [byte_type] in\r\n    let _               = codegen_block extend in\r\n    let extend_par      = param extend 0 in\r\n    let extend_ret      = build_zext extend_par int_type \"extend\" builder in\r\n    let _               = build_ret extend_ret builder in\r\n\r\n    (* writeByte (b : byte) : proc *)\r\n    let writeByte       = codegen_declare \"writeByte\" proc_type [byte_type] in\r\n    let _               = codegen_block writeByte in\r\n    let writeByte_par   = param writeByte 0 in\r\n    let from_extend     = build_call extend [|writeByte_par|] \"extend call\" builder in\r\n    let writeInteger    = match lookup_function \"writeInteger\" the_module with | Some fn -> fn | _ -> fatal \"writeInteger missing\"; raise Terminate in\r\n    let _               = build_call writeInteger [|from_extend|] \"writeInteger call\" builder in\r\n    let _               = build_ret_void builder in\r\n\r\n    (* shrink (i : int) : byte *)\r\n    let shrink          = codegen_declare \"shrink\" byte_type [int_type] in\r\n    let _               = codegen_block shrink in\r\n    let shrink_par      = param shrink 0 in\r\n    let shrink_ret      = build_trunc shrink_par byte_type \"shrink\" builder in\r\n    let _               = build_ret shrink_ret builder in\r\n\r\n    (* readByte () : byte *)\r\n    let readByte        = codegen_declare \"readByte\" byte_type [] in\r\n    let _               = codegen_block readByte in\r\n    let readInteger     = match lookup_function \"readInteger\" the_module with | Some fn -> fn | _ -> fatal \"readInteger missing\"; raise Terminate in\r\n    let from_readInt    = build_call readInteger [||] \"readInteger call\" builder in\r\n    let from_shrink     = build_call shrink [|from_readInt|] \"shrink call\" builder in\r\n    let _               = build_ret from_shrink builder in\r\n    \r\n    ()\r\n     \r\n\r\nlet codegen tree =\r\n\r\n    (* generate code for existing functions first *)\r\n    codegen_existing_functions ();\r\n\r\n    (* Top level function has no parent - assign dummy *)\r\n    tree.parent <- (Some {\r\n        full_name = \"\";\r\n        func_id = \"\";\r\n        func_pars = [];\r\n        func_ret_type = TYPE_none;\r\n        func_local = [];\r\n        func_stmt = [];\r\n        func_nesting_scope = 0;\r\n        parent = None;\r\n        frame_type = Some pointer_type bool_type;\r\n        isMain = false;\r\n    });\r\n    tree.isMain <- true;\r\n    \r\n    codegen_func tree;\r\n    print_endline \"before\";\r\n    assert_valid_module the_module;\r\n    print_endline \"yeah\";\r\n    dump_module the_module\r\n\r\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/vlassis/Desktop/Compiler/workspace/Ast.ml","languageId":"ocaml","version":1,"text":"open Types\r\nopen Symbol\r\nopen Llvm\r\nopen Identifier\r\n\r\ntype my_id = string\r\n\r\n(* type reference = Is_ref | Not_ref *)\r\n\r\n(*type pass_way = PASS_BY_REFERENCE | PASS_BY_VALUE*)\r\n\r\ntype sign = SPlus | SMinus\r\n\r\ntype op = \r\n| Plus\r\n| Minus\r\n| Mult\r\n| Div\r\n| Mod\r\n\r\ntype compare_op =\r\n| Eq\r\n| Neq\r\n| Less\r\n| Great\r\n| LessEq\r\n| GreatEq\r\n\r\ntype logic_op = \r\n| And\r\n| Or\r\n\r\n(*\r\ntype data_type =\r\n| Int\r\n| Byte\r\n\r\ntype _type = \r\n| Basic of data_type\r\n| Array of data_type\r\n*)\r\n\r\ntype func = {\r\n    mutable full_name : my_id;\r\n    func_id : my_id;\r\n    func_pars : par list;\r\n    func_ret_type : typ;\r\n    func_local : local list;\r\n    func_stmt : stmt list;\r\n    mutable func_nesting_scope : int;\r\n    mutable parent : func option;\r\n    mutable frame_type : lltype option;\r\n    mutable isMain : bool;\r\n}\r\n\r\nand par = {\r\n    par_id : my_id;\r\n    par_pass_way : pass_mode;\r\n    par_type : typ;\r\n    mutable par_offset: int;\r\n    mutable symb_id : Identifier.id option;\r\n}\r\n\r\nand local = \r\n| Local_func of func\r\n| Local_var of var\r\n\r\nand var = {\r\n    var_id : my_id;\r\n    var_type : typ;\r\n    mutable var_offset : int;\r\n}\r\n\r\nand stmt = \r\n| Null_stmt\r\n| S_assign of l_value * expr\r\n| S_comp of stmt list\r\n| S_call of call\r\n| S_if of cond * stmt * (stmt option)\r\n| S_while of cond * stmt\r\n| S_return of expr option\r\n\r\nand call = {\r\n    call_id : my_id;\r\n    call_expr : expr list;\r\n    mutable return_type : typ option;\r\n    mutable callee_full_name : my_id option;\r\n    mutable callee_scope : int;\r\n    mutable caller_nesting_scope : int;\r\n    mutable declared_pars : (pass_mode list) option;\r\n}\r\n\r\nand raw_expr = \r\n| E_int of int\r\n| E_char of char\r\n| E_lvalue of l_value\r\n| E_call of call\r\n| E_sign of sign * expr\r\n| E_op of expr * op * expr\r\n\r\nand expr = {\r\n    expr_raw : raw_expr;\r\n    mutable expr_type : typ option;\r\n}\r\n\r\nand raw_l_value = \r\n| L_id of my_id * (expr option)\r\n| L_str of string\r\n\r\nand l_value = {\r\n    l_value_raw : raw_l_value;\r\n    mutable l_value_type : typ option;\r\n    mutable l_value_nesting_diff : int;\r\n    mutable offset : int;\r\n    mutable is_reference : bool;\r\n    mutable is_parameter : bool;\r\n    mutable is_local : bool;\r\n}\r\n\r\nand cond = \r\n| C_true\r\n| C_false\r\n| C_not of cond\r\n| C_compare of expr * compare_op * expr\r\n| C_logic of cond * logic_op * cond\r\n\r\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///home/vlassis/Desktop/Compiler/workspace/Codegen.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00476837158203ms
Sending response {"id": 1, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///home/vlassis/Desktop/Compiler/workspace/Ast.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00309944152832ms
Sending response {"id": 2, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":3,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/vlassis/Desktop/Compiler/workspace/Ast.ml"},"range":{"start":{"line":70,"character":12},"end":{"line":70,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 3, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":4,"method":"shutdown","params":null}
Sending response {"id": 4, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"exit","params":null}
Got exit! Terminating loop
Finished
