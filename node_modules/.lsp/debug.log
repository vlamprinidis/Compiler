Hello - from /home/vlassis/.vscode/extensions/jaredly.reason-vscode-1.7.5/bin.native.linux
Previous log location: /tmp/lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json"}, {"globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/vlassis/Desktop/Compiler/workspace/Codegen.ml","languageId":"ocaml","version":1,"text":"open Llvm\r\nopen Llvm_analysis\r\nopen Ast\r\nopen Error\r\nopen Types\r\nopen Symbol\r\n\r\nexception Error of string\r\n\r\nlet context = global_context ()\r\nlet the_module = create_module context \"alan\"\r\nlet builder = builder context\r\n\r\nlet int_type = i16_type context (* lltype *)\r\nlet byte_type = i8_type context\r\nlet bool_type = i1_type context\r\nlet proc_type = void_type context\r\n\r\n(* Helping functions *)\r\n\r\nlet rec give_lltype alan_type =\r\n    begin match alan_type with\r\n        | TYPE_int                          -> int_type\r\n        | TYPE_byte                         -> byte_type\r\n        | TYPE_array (elem_type, arr_size)  -> array_type (give_lltype elem_type) arr_size (* element type can only be a basic data type in alan - int or byte *)\r\n        | _ -> fatal \"alan to lltype didn't work\"; raise Terminate\r\n    end\r\n\r\nlet rec give_fret_lltype alan_type =\r\n    begin match alan_type with\r\n        | TYPE_int  -> int_type\r\n        | TYPE_byte -> byte_type\r\n        | TYPE_proc -> proc_type\r\n        | _ -> fatal \"alan to return type didn't work\"; raise Terminate\r\n    end\r\n\r\nlet rec give_par_lltype_lst par_lst =\r\n    begin match par_lst with\r\n        | pr :: tl ->\r\n            begin match pr.par_pass_way with\r\n                | PASS_BY_VALUE     -> (give_lltype pr.par_type) :: (give_par_lltype_lst tl)\r\n                | PASS_BY_REFERENCE -> \r\n                    begin match pr.par_type with\r\n                        | TYPE_array (arr_pr_type, _) -> (pointer_type (give_lltype arr_pr_type)) :: (give_par_lltype_lst tl)\r\n                        | no_arr_pr_type              -> (pointer_type (give_lltype no_arr_pr_type)) :: (give_par_lltype_lst tl)\r\n                    end\r\n            end\r\n        | [] -> []\r\n    end\r\n\r\nlet rec give_locvar_lltype_lst loc_lst =\r\n    begin match loc_lst with\r\n        | (Local_var vr) :: tl  -> (give_lltype vr.var_type) :: (give_locvar_lltype_lst tl)\r\n        | (Local_func _) :: tl  -> give_locvar_lltype_lst tl\r\n        | []                    -> []\r\n    end\r\n\r\nlet give_frame_lltype func_pars func_local parent_frame_type =\r\n\r\n    let par_lltype_lst = give_par_lltype_lst func_pars in (* List of parameter lltypes *)\r\n    let locvar_lltype_lst = give_locvar_lltype_lst func_local in (* List of local-variable lltyppes (without local funcs) *)\r\n\r\n    let access_link_type = pointer_type parent_frame_type in \r\n\r\n    let arr_of_lltypes = Array.of_list ( access_link_type :: (par_lltype_lst @ locvar_lltype_lst) ) in (* Array of lltypes for frame lltype *)\r\n    let ll_frame_type = struct_type context arr_of_lltypes in (* Frame lltype (llvm-struct type) *)\r\n\r\n    ll_frame_type\r\n\r\nlet give_func_lltype func_pars func_ret_type  =\r\n\r\n    let par_lltype_lst = give_par_lltype_lst func_pars in (* List of parameter lltypes *)\r\n    let par_llarr = Array.of_list par_lltype_lst in (* Arrays of the above *)\r\n    \r\n    let fret_lltype = give_fret_lltype func_ret_type in (* LLtype of function's return value *)\r\n\r\n    let func_lltype = function_type fret_lltype par_llarr in (*Function lltype *)\r\n\r\n    func_lltype\r\n\r\nlet get_ptr_to_Nth_element struct_ptr n str = build_struct_gep struct_ptr n str builder\r\n\r\nlet dereference ptr = build_load ptr \"de-reference\" builder\r\n\r\nlet get_Nth_element struct_ptr n str =\r\n    let ptr_to_element = get_ptr_to_Nth_element struct_ptr n str in\r\n    dereference ptr_to_element\r\n\r\n(* Note: access_link == frame_ptr *)\r\nlet rec get_deep_access_link frame_ptr diff =\r\n    if( diff = 0 ) \r\n    then begin\r\n        frame_ptr\r\n    end\r\n    else begin\r\n        let first_element = get_Nth_element frame_ptr 0 \"access_link\" in\r\n        get_deep_access_link first_element (diff-1)\r\n    end\r\n    \r\n(* End of helping functions *)\r\n\r\nlet rec codegen_func func_ast =\r\n    \r\n    let func_lltype = give_func_lltype func_ast.func_pars func_ast.func_ret_type in (*Function lltype *)\r\n    (* Declare first *)\r\n    let func_llvalue = declare_function func_ast.full_name func_lltype the_module in\r\n\r\n    let parent_frame_type = match func_ast.parent with \r\n        | Some some_parent ->\r\n            begin match some_parent.frame_type with\r\n                | Some some_frame_type -> some_frame_type\r\n                | None -> fatal \"parent function does not have a frame type\"; raise Terminate\r\n            end\r\n        | None -> fatal \"function does not have a parent\"; raise Terminate\r\n    in\r\n\r\n    let frame_type = give_frame_lltype func_ast.func_pars func_ast.func_local parent_frame_type in\r\n    func_ast.frame_type <- Some frame_type;\r\n\r\n    (* Generate code for local functions *)\r\n    let gen_loc_func loc = match loc with\r\n        | Local_func loc_func -> codegen_func loc_func\r\n        | Local_var _         -> ()  \r\n    in\r\n    List.iter gen_loc_func func_ast.func_local;\r\n\r\n    (* Create function basic-block *)\r\n    let f_bb = append_block context \"entry block\" func_llvalue in\r\n    position_at_end f_bb builder;\r\n\r\n\r\n    (* Create frame *)\r\n    let frame_ptr = build_alloca frame_type \"frame\" builder in\r\n\r\n    let store_at valuetostore_llvalue idx =\r\n        let element_ptr_llvalue = build_struct_gep frame_ptr idx \"GEP\" builder in\r\n        ignore (build_store valuetostore_llvalue element_ptr_llvalue builder)\r\n    in\r\n    \r\n    (* Store each parameter into the frame *)\r\n    let rec store_par_llvalue_lst_to_frame par_llvalue_lst idx = match par_llvalue_lst with\r\n        | par_llvalue :: tl ->\r\n            store_at par_llvalue idx;\r\n            store_par_llvalue_lst_to_frame tl (idx+1)\r\n        | []                -> ()\r\n    in\r\n\r\n    let par_llvalue_lst = Array.to_list (params func_llvalue) in\r\n    (* Store starting from position 0 -- access link is included*)\r\n    store_par_llvalue_lst_to_frame par_llvalue_lst 0;\r\n    \r\n    (* Generate code for statements *)\r\n    ignore ( List.fold_left (codegen_stmt_until frame_ptr) false func_ast.func_stmt )\r\n    \r\n    (* List.iter (codegen_stmt frame_ptr) func_ast.func_stmt ; *)\r\n\r\nand codegen_call frame_ptr call_ast =\r\n    let rec give_expr_llvalue_lst expr_lst = match expr_lst with\r\n        | exr :: tl -> (print_endline \"okcgen\"; codegen_expr frame_ptr exr) :: (give_expr_llvalue_lst tl)\r\n        | []        -> []  \r\n    in\r\n\r\n    (* https://en.wikipedia.org/wiki/Nested_function *)\r\n    let callee_full_name = match call_ast.callee_full_name with\r\n        | Some name -> name\r\n        | None      -> fatal \"callee func ast full name error\"; raise Terminate\r\n    in\r\n    \r\n    let callee_func_llvalue = match (lookup_function callee_full_name the_module) with\r\n        | Some fn   -> fn\r\n        | None      -> fatal \"Function not found\"; raise Terminate\r\n    in\r\n\r\n    (* Must check if the callee is an existing function that doesn't need an access link *)\r\n    (* Idea: compare number of arguments in expr list with arguments declared through llvm *)\r\n\r\n    let access_link_is_required = \r\n        let llvm_args_num = Array.length (params callee_func_llvalue) in\r\n        let expr_args_num = List.length call_ast.call_expr in\r\n        if ( llvm_args_num = expr_args_num ) then ( false ) else ( true )\r\n    in\r\n\r\n    let expr_arr = \r\n        let expr_llvalue_lst = give_expr_llvalue_lst call_ast.call_expr in\r\n        \r\n        if ( access_link_is_required ) then begin\r\n            print_endline \"yok\";\r\n            let diff = call_ast.caller_nesting_scope - call_ast.callee_scope + 1  in\r\n            let correct_frame = get_deep_access_link frame_ptr diff in\r\n\r\n            Array.of_list ( correct_frame :: expr_llvalue_lst )\r\n        end \r\n        else begin\r\n            print_endline \"nok\";\r\n            Array.of_list expr_llvalue_lst\r\n        end\r\n    in\r\n    build_call callee_func_llvalue expr_arr \"call\" builder\r\n\r\nand codegen_stmt_until frame_ptr previous_stmt_is_terminator st  = (* returns true if terminal *)\r\n    previous_stmt_is_terminator || codegen_stmt frame_ptr st\r\n\r\nand codegen_stmt frame_ptr stmt_ast = (* returns true if terminal *)\r\n    begin match stmt_ast with\r\n        | Null_stmt                 ->\r\n            false\r\n\r\n        | S_assign (lval,exr)        ->\r\n            let exr_llvalue = codegen_expr frame_ptr exr in\r\n            let element_ptr = codegen_lval frame_ptr lval in\r\n            ignore (build_store exr_llvalue element_ptr builder);\r\n            false\r\n\r\n        | S_comp st_lst             ->\r\n            List.fold_left (codegen_stmt_until frame_ptr) false st_lst\r\n            \r\n            (* List.iter (codegen_stmt frame_ptr) st_lst; *)\r\n\r\n        | S_call fcall              -> (* Call to a void function *)\r\n            ignore (codegen_call frame_ptr fcall);\r\n            false\r\n\r\n        | S_if (cnd, st, st_option) ->\r\n        (* http://llvm.org/docs/tutorial/OCamlLangImpl5.html *)\r\n            let cond_val = codegen_cond frame_ptr cnd in\r\n\r\n            (* Grab the first block so that we might later add the conditional branch\r\n            * to it at the end of the function. *)\r\n            let start_bb = insertion_block builder in\r\n            let the_function = block_parent start_bb in\r\n\r\n            let then_bb = append_block context \"then\" the_function in\r\n            let merge_bb = append_block context \"ifcont\" the_function in\r\n\r\n            position_at_end then_bb builder;\r\n            let then_stmt_is_terminal = codegen_stmt frame_ptr st in\r\n            let new_then_bb = insertion_block builder in (* Codegen of 'then' can change the current block *)\r\n\r\n            if(not then_stmt_is_terminal)\r\n            then begin\r\n                (* Set an unconditional branch at the end of the then-block to the merge-block *)\r\n                position_at_end new_then_bb builder; \r\n                ignore (build_br merge_bb builder)\r\n            end ;\r\n\r\n            let _ = match st_option with\r\n                | Some st_some ->\r\n                    let else_bb = append_block context \"else\" the_function in\r\n\r\n                    position_at_end else_bb builder;\r\n                    let else_stmt_is_terminal = codegen_stmt frame_ptr st_some in\r\n                    let new_else_bb = insertion_block builder in\r\n\r\n                    if( not else_stmt_is_terminal)\r\n                    then begin\r\n                        (* Set an unconditional branch at the end of the else-block to the merge-block*)\r\n                        position_at_end new_else_bb builder; \r\n                        ignore (build_br merge_bb builder)\r\n                    end;\r\n\r\n                    (* Return to the end of the start-block to add the conditional branch *)\r\n                    position_at_end start_bb builder;\r\n                    ignore ( build_cond_br cond_val then_bb else_bb builder )\r\n                    \r\n                    (* position_at_end merge_bb builder; *)\r\n                    (* then_stmt_is_terminal && else_stmt_is_terminal *)\r\n\r\n                | None ->\r\n                    (* Return to the end of the start-block to add the conditional branch *)\r\n                    position_at_end start_bb builder;\r\n                    ignore ( build_cond_br cond_val then_bb merge_bb builder )\r\n\r\n                    (* position_at_end merge_bb builder; *)\r\n                    (* false *)\r\n\r\n            in\r\n            (* Finally, set the builder to the end of the merge-block *)\r\n            position_at_end merge_bb builder;\r\n            false\r\n\r\n        | S_while (cnd, st)          ->\r\n            (* Grab the first block so that we later add the unconditional branch\r\n            * to it at the end of the function. *)\r\n            let start_bb = insertion_block builder in\r\n            let the_function = block_parent start_bb in\r\n\r\n            let while_bb = append_block context \"while\" the_function in\r\n            let do_bb = append_block context \"do\" the_function in\r\n            let merge_bb = append_block context \"continue\" the_function in\r\n\r\n            (* Set an unconditional branch at the end of the 'start' block to the start of the while-block *)\r\n            position_at_end start_bb builder; \r\n            ignore (build_br while_bb builder);\r\n\r\n            position_at_end while_bb builder;  \r\n            let cond_val = codegen_cond frame_ptr cnd in\r\n            let new_while_bb = insertion_block builder in (* Codegen of 'while' can change the current block *)\r\n            (* Add the conditional branch to either the do-block or the merge-block*)\r\n            position_at_end new_while_bb builder;\r\n            ignore (build_cond_br cond_val do_bb merge_bb builder);      \r\n\r\n            position_at_end do_bb builder;\r\n            let while_st_is_terminator = codegen_stmt frame_ptr st in\r\n            let new_do_bb = insertion_block builder in (* Codegen of 'do' can change the current block *)\r\n            \r\n            if (not while_st_is_terminator) then \r\n            begin\r\n                (* Set an unconditional branch to the start of the while-block *)\r\n                position_at_end new_do_bb builder; \r\n                ignore (build_br while_bb builder)\r\n            end;\r\n\r\n            (* Finally, set the builder to the end of the merge-block. *)\r\n            position_at_end merge_bb builder;\r\n\r\n            false\r\n\r\n        | S_return None             ->\r\n            ignore (build_ret_void builder);\r\n            true\r\n\r\n        | S_return (Some exr)        ->\r\n            let to_return_llvalue = codegen_expr frame_ptr exr in\r\n            ignore (build_ret to_return_llvalue builder);\r\n            true\r\n    end\r\n\r\nand codegen_expr frame_ptr expr_ast = \r\n    begin match expr_ast.expr_raw with\r\n        | E_int n                   -> const_int int_type n\r\n        | E_char c                  -> const_int byte_type (Char.code c)\r\n        | E_val v                   -> dereference (codegen_lval frame_ptr v)\r\n        | E_call cl                 -> codegen_call frame_ptr cl\r\n        | E_sign (SPlus,exr)        -> codegen_expr frame_ptr exr\r\n        | E_sign (SMinus,exr)       -> build_neg (codegen_expr frame_ptr exr) \"neg\" builder\r\n        | E_op (er1, er_op, er2)    ->\r\n            let ller1 = codegen_expr frame_ptr er1 in\r\n            let ller2 = codegen_expr frame_ptr er2 in\r\n            begin match er_op with\r\n                | Plus  -> build_add ller1 ller2 \"add\" builder\r\n                | Minus -> build_sub ller1 ller2 \"sub\" builder\r\n                | Mult  -> build_mul ller1 ller2 \"mul\" builder\r\n                | Div   -> \r\n                    begin match (er1.expr_type, er2.expr_type) with \r\n                        | (Some TYPE_int, Some TYPE_int)   -> build_sdiv ller1 ller2 \"sdiv\" builder\r\n                        | (Some TYPE_byte, Some TYPE_byte) -> build_udiv ller1 ller2 \"udiv\" builder\r\n                        | _ -> fatal \"exprgen div, type mismatch\"; raise Terminate\r\n                    end\r\n                | Mod   -> \r\n                    begin match (er1.expr_type, er2.expr_type) with \r\n                        | (Some TYPE_int, Some TYPE_int)   -> build_srem ller1 ller2 \"smod\" builder\r\n                        | (Some TYPE_byte, Some TYPE_byte) -> build_urem ller1 ller2 \"umod\" builder\r\n                        | _ -> fatal \"exprgen mod, type mismatch\"; raise Terminate\r\n                    end\r\n            end \r\n    end\r\n\r\nand codegen_lval frame_ptr l_value_ast = (* This will always return a pointer to an element *)\r\n    let correct_frame = get_deep_access_link frame_ptr l_value_ast.l_value_nesting_diff in\r\n\r\n    begin match l_value_ast.l_value_raw with\r\n        | L_id (lval_id, None) ->\r\n            begin match l_value_ast.is_parameter, l_value_ast.is_local with\r\n\r\n                (* Parameters *)\r\n                | true, false -> \r\n                    begin match l_value_ast.l_value_type with\r\n                        | Some (TYPE_array (arr_typ,_)) -> (* Arrays are passed by reference only - They are pointers to the first element (of the array) in the frames *)\r\n                            get_Nth_element correct_frame l_value_ast.offset lval_id\r\n                        | Some _                        ->\r\n                            begin match l_value_ast.is_reference with\r\n                                | true  -> get_Nth_element correct_frame l_value_ast.offset lval_id\r\n                                | false -> get_ptr_to_Nth_element correct_frame l_value_ast.offset lval_id\r\n                            end\r\n                        | _                             -> fatal \"none,params\"; raise Terminate\r\n                    end\r\n\r\n                (* Locals *)\r\n                | false, true -> \r\n                    begin match l_value_ast.l_value_type with\r\n                        | Some (TYPE_array (arr_typ,_)) -> (* Array_type in frame here -- get pointer to the first element of the array *)\r\n                            let array_in_frame = get_Nth_element correct_frame l_value_ast.offset lval_id in\r\n                            get_ptr_to_Nth_element array_in_frame 0 lval_id\r\n                        | Some _                        -> (* No references here *)\r\n                            get_ptr_to_Nth_element correct_frame l_value_ast.offset lval_id\r\n                        | _                             -> fatal \"none, locals\"; raise Terminate\r\n                    end\r\n                | _           -> fatal \"none, false, false\"; raise Terminate\r\n            end\r\n\r\n        | L_id (lval_id,Some exr) -> (* Only arrays here *)\r\n            begin match l_value_ast.is_parameter, l_value_ast.is_local with\r\n\r\n                (* Parameters *)\r\n                | true, false -> \r\n                    let exr_llvalue = codegen_expr frame_ptr exr in\r\n                    let arr_ptr = get_Nth_element correct_frame l_value_ast.offset lval_id in\r\n                    build_gep arr_ptr [|exr_llvalue|] \"identifier with some expression-param\" builder\r\n\r\n                (* Locals *)\r\n                | false, true -> \r\n                    let exr_llvalue = codegen_expr frame_ptr exr in\r\n                    let array_in_frame = get_Nth_element correct_frame l_value_ast.offset lval_id in\r\n                    let arr_ptr = get_ptr_to_Nth_element array_in_frame 0 lval_id in\r\n                    build_gep arr_ptr [|exr_llvalue|] \"identifier with some expression-local\" builder\r\n\r\n                | _           -> fatal \"some, false, false\"; raise Terminate\r\n            end\r\n\r\n        | L_str str                 -> \r\n            let global_str = build_global_stringptr str \"string to build\" builder in\r\n            build_struct_gep global_str 0 \"string as a char ptr\" builder\r\n    end\r\n\r\nand codegen_cond frame_ptr cond_ast =\r\n    let give_ll_cmp_op alan_op is_signed = match is_signed, alan_op with\r\n        | _, Eq -> Icmp.Eq\r\n        | _, Neq -> Icmp.Ne\r\n\r\n        | true, Less -> Icmp.Slt\r\n        | true, Great -> Icmp.Sgt\r\n        | true, LessEq -> Icmp.Sle\r\n        | true, GreatEq -> Icmp.Sge\r\n\r\n        | false, Less -> Icmp.Ult\r\n        | false, Great -> Icmp.Ugt\r\n        | false, LessEq -> Icmp.Ule\r\n        | false, GreatEq -> Icmp.Uge\r\n    in\r\n\r\n    let is_expr_signed exr = match exr.expr_type with\r\n        | Some TYPE_int     -> true\r\n        | Some TYPE_byte    -> false\r\n        | _                 -> fatal \"is_expr_signed: type is not int or byte\"; raise Terminate\r\n    in\r\n\r\n    begin match cond_ast with\r\n        | C_true                        -> const_int bool_type 1\r\n        | C_false                       -> const_int bool_type 0\r\n        | C_not cnd                     -> build_not (codegen_cond frame_ptr cnd) \"not\" builder\r\n        | C_compare (er1, cmp_op, er2)  -> build_icmp (give_ll_cmp_op cmp_op (is_expr_signed er1)) (codegen_expr frame_ptr er1) (codegen_expr frame_ptr er2) \"icmp\" builder\r\n        | C_logic (cnd1, lg_op, cnd2)   ->\r\n            let start_bb = insertion_block builder in\r\n            let the_function = block_parent start_bb in\r\n\r\n            let middle_bb = append_block context \"middle_bb\" the_function in\r\n            let merge_bb = append_block context \"merge_bb\" the_function in\r\n\r\n            (* position_at_end start_bb builder; *)\r\n            let cnd1_llvalue = codegen_cond frame_ptr cnd1 in\r\n\r\n            let midway logical_operator = match logical_operator with\r\n                | And ->\r\n                    (* If cnd1 is true then (must compute cnd2) middle_bb else merge_bb *)\r\n                    ignore (build_cond_br cnd1_llvalue middle_bb merge_bb builder);\r\n                    let new_start_bb = insertion_block builder in\r\n\r\n                    position_at_end middle_bb builder;\r\n                    let middle_llvalue = build_and cnd1_llvalue (codegen_cond frame_ptr cnd2) \"and\" builder in\r\n                    ignore (build_br merge_bb builder);\r\n                    let new_middle_bb = insertion_block builder in\r\n\r\n                    (new_start_bb, middle_llvalue, new_middle_bb)\r\n\r\n                | Or  ->\r\n                    (* If cnd1 is true then (no need to compute cnd2) merge_bb else middle_bb *)\r\n                    ignore (build_cond_br cnd1_llvalue merge_bb middle_bb builder);\r\n                    let new_start_bb = insertion_block builder in\r\n\r\n                    position_at_end middle_bb builder;\r\n                    let middle_llvalue = build_or cnd1_llvalue (codegen_cond frame_ptr cnd2) \"or\" builder in\r\n                    ignore (build_br merge_bb builder);\r\n                    let new_middle_bb = insertion_block builder in\r\n                    \r\n                    (new_start_bb, middle_llvalue, new_middle_bb)\r\n            in\r\n\r\n            let (new_start_bb, middle_llvalue, new_middle_bb) = midway lg_op in\r\n\r\n            position_at_end merge_bb builder;\r\n            let phi = build_phi [(cnd1_llvalue, new_start_bb) ; (middle_llvalue, new_middle_bb)] \"phi\" builder in\r\n            position_at_end merge_bb builder;\r\n            phi\r\n    end\r\n\r\nlet codegen_existing_functions () = \r\n    \r\n    let codegen_block func_llvalue =\r\n        (* Create function basic-block *)\r\n        let f_bb = append_block context \"entry block\" func_llvalue in\r\n        position_at_end f_bb builder\r\n    in\r\n\r\n    let codegen_declare full_name ret_type pars = \r\n        let pars_arr = Array.of_list pars in\r\n        let func_lltype = function_type ret_type pars_arr in\r\n        declare_function full_name func_lltype the_module\r\n    in\r\n\r\n    let writeInteger    = codegen_declare \"writeInteger\"    proc_type [int_type] in\r\n    let _               = codegen_declare \"writeChar\"       proc_type [byte_type] in\r\n    let _               = codegen_declare \"writeString\"     proc_type [pointer_type byte_type] in\r\n    let readInteger     = codegen_declare \"readInteger\"     int_type  [] in\r\n    let _               = codegen_declare \"readChar\"        byte_type [] in\r\n    let _               = codegen_declare \"readString\"      proc_type [int_type; pointer_type byte_type] in\r\n    let _               = codegen_declare \"strlen\"          int_type  [pointer_type byte_type] in\r\n    let _               = codegen_declare \"strcmp\"          int_type  [pointer_type byte_type; pointer_type byte_type] in\r\n    let _               = codegen_declare \"strcpy\"          proc_type [pointer_type byte_type; pointer_type byte_type] in\r\n    let _               = codegen_declare \"strcat\"          proc_type [pointer_type byte_type; pointer_type byte_type] in\r\n\r\n    (* extend (b : byte) : int *)\r\n    let extend          = codegen_declare \"extend\" int_type [byte_type] in\r\n    let _               = codegen_block extend in\r\n    let extend_par      = param extend 0 in\r\n    let extend_ret      = build_zext extend_par int_type \"extend\" builder in\r\n    let _               = build_ret extend_ret builder in\r\n\r\n    (* writeByte (b : byte) : proc *)\r\n    let writeByte       = codegen_declare \"writeByte\" proc_type [byte_type] in\r\n    let _               = codegen_block writeByte in\r\n    let writeByte_par   = param writeByte 0 in\r\n    let from_extend     = build_call extend [|writeByte_par|] \"extend call\" builder in\r\n    let _               = build_call writeInteger [|from_extend|] \"writeInteger call\" builder in\r\n    let _               = build_ret_void builder in\r\n\r\n    (* shrink (i : int) : byte *)\r\n    let shrink          = codegen_declare \"shrink\" byte_type [int_type] in\r\n    let _               = codegen_block shrink in\r\n    let shrink_par      = param shrink 0 in\r\n    let shrink_ret      = build_trunc shrink_par byte_type \"shrink\" builder in\r\n    let _               = build_ret shrink_ret builder in\r\n\r\n    (* readByte () : byte *)\r\n    let readByte        = codegen_declare \"readByte\" byte_type [] in\r\n    let _               = codegen_block readByte in\r\n    let from_readInt    = build_call readInteger [||] \"readInteger call\" builder in\r\n    let from_shrink     = build_call shrink [|from_readInt|] \"shrink call\" builder in\r\n    let _               = build_ret from_shrink builder in\r\n    \r\n    ()\r\n     \r\n\r\nlet codegen tree =\r\n\r\n    (* generate code for existing functions first *)\r\n    codegen_existing_functions ();\r\n\r\n    (* Top level function has no parent - assign self *)\r\n    tree.parent <- Some tree;\r\n    (* Top level function has no frame_type - assign a dummy *)\r\n    tree.frame_type <- Some pointer_type bool_type;\r\n    \r\n    codegen_func tree;\r\n    print_endline \"before\";\r\n    assert_valid_module the_module;\r\n    print_endline \"yeah\";\r\n    dump_module the_module\r\n\r\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///home/vlassis/Desktop/Compiler/workspace/Codegen.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/vlassis/Desktop/Compiler/workspace/Codegen.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00381469726562ms
Sending response {"id": 2, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":3,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/vlassis/Desktop/Compiler/workspace/Codegen.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 3, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":4,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///home/vlassis/Desktop/Compiler/workspace/Codegen.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 4, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":5,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/vlassis/Desktop/Compiler/workspace/Codegen.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00715255737305ms
Sending response {"id": 5, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
